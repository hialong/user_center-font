<!DOCTYPE html> <html><head>
		<title>平衡多路查找树（B树）</title>
		<base href="..\..\../">
		<meta id="root-path" root-path="..\..\../">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes, minimum-scale=1.0, maximum-scale=5.0">
		<meta charset="UTF-8">
		<meta name="description" content="myVault - 平衡多路查找树（B树）">
		<meta property="og:title" content="平衡多路查找树（B树）">
		<meta property="og:description" content="myVault - 平衡多路查找树（B树）">
		<meta property="og:type" content="website">
		<meta property="og:url" content="2-领域/后端学习/java/平衡多路查找树（b树）.html">
		<meta property="og:image" content="https://obsidian-pic-1317906728.cos.ap-nanjing.myqcloud.com/obsidian/20240220233103.png">
		<meta property="og:site_name" content="myVault">
		<link rel="alternate" type="application/rss+xml" title="RSS Feed" href="lib/rss.xml"><script async="" id="webpage-script" src="lib/scripts/webpage.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><script type="module" async="" id="graph-view-script" src="lib/scripts/graph-view.js"></script><script async="" id="graph-wasm-script" src="lib/scripts/graph-wasm.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><script async="" id="graph-render-worker-script" src="lib/scripts/graph-render-worker.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><script async="" id="tinycolor-script" src="lib/scripts/tinycolor.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><script async="" id="pixi-script" src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/7.4.0/pixi.min.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><script async="" id="minisearch-script" src="https://cdn.jsdelivr.net/npm/minisearch@6.3.0/dist/umd/index.min.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><link rel="icon" href="lib/media/favicon.png"><script async="" id="graph-data-script" src="lib/scripts/graph-data.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><style>body{--line-width:40em;--line-width-adaptive:40em;--file-line-width:40em;--sidebar-width:min(20em, 80vw);--collapse-arrow-size:11px;--tree-horizontal-spacing:0.6em;--tree-vertical-spacing:0.6em;--sidebar-margin:12px}.sidebar{height:100%;min-width:calc(var(--sidebar-width) + var(--divider-width-hover));max-width:calc(var(--sidebar-width) + var(--divider-width-hover));font-size:14px;z-index:10;position:relative;overflow:hidden;transition:min-width ease-in-out,max-width ease-in-out;transition-duration:.2s;contain:size}.sidebar-left{left:0}.sidebar-right{right:0}.sidebar.is-collapsed{min-width:0;max-width:0}body.floating-sidebars .sidebar{position:absolute}.sidebar-content{height:100%;min-width:calc(var(--sidebar-width) - var(--divider-width-hover));top:0;padding:var(--sidebar-margin);padding-top:4em;line-height:var(--line-height-tight);background-color:var(--background-secondary);transition:background-color,border-right,border-left,box-shadow;transition-duration:var(--color-fade-speed);transition-timing-function:ease-in-out;position:absolute;display:flex;flex-direction:column}.sidebar:not(.is-collapsed) .sidebar-content{min-width:calc(max(100%,var(--sidebar-width)) - 3px);max-width:calc(max(100%,var(--sidebar-width)) - 3px)}.sidebar-left .sidebar-content{left:0;border-top-right-radius:var(--radius-l);border-bottom-right-radius:var(--radius-l)}.sidebar-right .sidebar-content{right:0;border-top-left-radius:var(--radius-l);border-bottom-left-radius:var(--radius-l)}.sidebar:has(.sidebar-content:empty):has(.topbar-content:empty){display:none}.sidebar-topbar{height:2em;width:var(--sidebar-width);top:var(--sidebar-margin);padding-inline:var(--sidebar-margin);z-index:1;position:fixed;display:flex;align-items:center;transition:width ease-in-out;transition-duration:inherit}.sidebar.is-collapsed .sidebar-topbar{width:calc(2.3em + var(--sidebar-margin) * 2)}.sidebar .sidebar-topbar.is-collapsed{width:0}.sidebar-left .sidebar-topbar{left:0}.sidebar-right .sidebar-topbar{right:0}.topbar-content{overflow:hidden;overflow:clip;width:100%;height:100%;display:flex;align-items:center;transition:inherit}.sidebar.is-collapsed .topbar-content{width:0;transition:inherit}.clickable-icon.sidebar-collapse-icon{background-color:transparent;color:var(--icon-color-focused);padding:0!important;margin:0!important;height:100%!important;width:2.3em!important;margin-inline:0.14em!important;position:absolute}.sidebar-left .clickable-icon.sidebar-collapse-icon{transform:rotateY(180deg);right:var(--sidebar-margin)}.sidebar-right .clickable-icon.sidebar-collapse-icon{transform:rotateY(180deg);left:var(--sidebar-margin)}.clickable-icon.sidebar-collapse-icon svg.svg-icon{width:100%;height:100%}.sidebar-section-header{margin:0 0 1em 0;text-transform:uppercase;letter-spacing:.06em;font-weight:600}body{transition:background-color var(--color-fade-speed) ease-in-out}.webpage-container{display:flex;flex-direction:row;height:100%;width:100%;align-items:stretch;justify-content:center}.document-container{opacity:1;flex-basis:100%;max-width:100%;width:100%;height:100%;display:flex;flex-direction:column;align-items:center;transition:opacity .2s ease-in-out;contain:inline-size}.hide{opacity:0;transition:opacity .2s ease-in-out}.document-container>.markdown-preview-view{margin:var(--sidebar-margin);margin-bottom:0;width:100%;width:-webkit-fill-available;width:-moz-available;width:fill-available;background-color:var(--background-primary);transition:background-color var(--color-fade-speed) ease-in-out;border-top-right-radius:var(--window-radius,var(--radius-m));border-top-left-radius:var(--window-radius,var(--radius-m));overflow-x:hidden!important;overflow-y:auto!important;display:flex!important;flex-direction:column!important;align-items:center!important;contain:inline-size}.document-container>.markdown-preview-view>.markdown-preview-sizer{padding-bottom:80vh!important;width:100%!important;max-width:var(--line-width)!important;flex-basis:var(--line-width)!important;transition:background-color var(--color-fade-speed) ease-in-out;contain:inline-size}.markdown-rendered img:not([width]),.view-content img:not([width]){max-width:100%;outline:0}.document-container>.view-content.embed{display:flex;padding:1em;height:100%;width:100%;align-items:center;justify-content:center}.document-container>.view-content.embed>*{max-width:100%;max-height:100%;object-fit:contain}:has(> :is(.math,table)){overflow-x:auto!important}.document-container>.view-content{overflow-x:auto;contain:content;padding:0;margin:0;height:100%}.scroll-highlight{position:absolute;width:100%;height:100%;pointer-events:none;z-index:1000;background-color:hsla(var(--color-accent-hsl),.25);opacity:0;padding:1em;inset:50%;translate:-50% -50%;border-radius:var(--radius-s)}</style><script defer="">async function loadIncludes(){if("file:"!=location.protocol){let e=document.querySelectorAll("include");for(let t=0;t<e.length;t++){let o=e[t],l=o.getAttribute("src");try{const e=await fetch(l);if(!e.ok){console.log("Could not include file: "+l),o?.remove();continue}let t=await e.text(),n=document.createRange().createContextualFragment(t),i=Array.from(n.children);for(let e of i)e.classList.add("hide"),e.style.transition="opacity 0.5s ease-in-out",setTimeout((()=>{e.classList.remove("hide")}),10);o.before(n),o.remove(),console.log("Included file: "+l)}catch(e){o?.remove(),console.log("Could not include file: "+l,e);continue}}}else{if(document.querySelectorAll("include").length>0){var e=document.createElement("div");e.id="error",e.textContent="Web server exports must be hosted on an http / web server to be viewed correctly.",e.style.position="fixed",e.style.top="50%",e.style.left="50%",e.style.transform="translate(-50%, -50%)",e.style.fontSize="1.5em",e.style.fontWeight="bold",e.style.textAlign="center",document.body.appendChild(e),document.querySelector(".document-container")?.classList.remove("hide")}}}document.addEventListener("DOMContentLoaded",(()=>{loadIncludes()}));let isFileProtocol="file:"==location.protocol;function waitLoadScripts(e,t){let o=e.map((e=>document.getElementById(e+"-script"))),l=0;!function e(){let n=o[l];l++,n&&"true"!=n.getAttribute("loaded")||l<o.length&&e(),l<o.length?n.addEventListener("load",e):t()}()}</script><link rel="stylesheet" href="lib/styles/obsidian.css"><link rel="stylesheet" href="lib/styles/theme.css"><link rel="preload" href="lib/styles/global-variable-styles.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><noscript><link rel="stylesheet" href="lib/styles/global-variable-styles.css"></noscript><link rel="preload" href="lib/styles/supported-plugins.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><noscript><link rel="stylesheet" href="lib/styles/supported-plugins.css"></noscript><link rel="preload" href="lib/styles/main-styles.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><noscript><link rel="stylesheet" href="lib/styles/main-styles.css"></noscript></head><body class="publish css-settings-manager theme-dark show-inline-title minimal-flexoki-dark colorful-headings colorful-active links-int-on links-ext-on full-width-media minimal-readable trim-cols styled-scrollbars"><script defer="">let theme=localStorage.getItem("theme")||(window.matchMedia("(prefers-color-scheme: dark)").matches?"dark":"light");"dark"==theme?(document.body.classList.add("theme-dark"),document.body.classList.remove("theme-light")):(document.body.classList.add("theme-light"),document.body.classList.remove("theme-dark")),window.innerWidth<480?document.body.classList.add("is-phone"):window.innerWidth<768?document.body.classList.add("is-tablet"):window.innerWidth<1024?document.body.classList.add("is-small-screen"):document.body.classList.add("is-large-screen")</script><div class="webpage-container workspace"><div class="sidebar-left sidebar"><div class="sidebar-handle"></div><div class="sidebar-topbar"><div class="topbar-content"><label class="theme-toggle-container" for="theme_toggle"><input class="theme-toggle-input" type="checkbox" id="theme_toggle"><div class="toggle-background"></div></label></div><div class="clickable-icon sidebar-collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="100%" height="100%" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" class="svg-icon"><path d="M21 3H3C1.89543 3 1 3.89543 1 5V19C1 20.1046 1.89543 21 3 21H21C22.1046 21 23 20.1046 23 19V5C23 3.89543 22.1046 3 21 3Z"></path><path d="M10 4V20"></path><path d="M4 7H7"></path><path d="M4 10H7"></path><path d="M4 13H7"></path></svg></div></div><div class="sidebar-content"><div class="search-input-container"><input enterkeyhint="search" type="search" spellcheck="false" placeholder="Search..."><div class="search-input-clear-button" aria-label="Clear search"></div></div><include src="lib/html/file-tree.html"></include></div><script defer="">let ls = document.querySelector(".sidebar-left"); ls.classList.add("is-collapsed"); if (window.innerWidth > 768) ls.classList.remove("is-collapsed"); ls.style.setProperty("--sidebar-width", localStorage.getItem("sidebar-left-width"));</script></div><div class="document-container markdown-reading-view hide"><div class="markdown-preview-view markdown-rendered allow-fold-headings allow-fold-lists is-readable-line-width"><style id="MJX-CHTML-styles"></style><pre class="frontmatter language-yaml" tabindex="0" style="display: none;"><code class="language-yaml is-loaded"><span class="token key atrule">created</span><span class="token punctuation">:</span> <span class="token datetime number">2024-02-20</span>
<span class="token key atrule">updated</span><span class="token punctuation">:</span> <span class="token datetime number">2024-02-20</span>
<span class="token key atrule">Type</span><span class="token punctuation">:</span>
  <span class="token punctuation">-</span> knowledge
<span class="token key atrule">Status</span><span class="token punctuation">:</span>
  <span class="token punctuation">-</span> ⌛️ 等待
<span class="token key atrule">tags</span><span class="token punctuation">:</span>
  <span class="token punctuation">-</span> 数据结构
<span class="token key atrule">aliases</span><span class="token punctuation">:</span>
  <span class="token punctuation">-</span> 平衡二叉树、B树、B+树、B<span class="token important">*树</span></code><button class="copy-code-button">复制</button></pre><div class="markdown-preview-sizer markdown-preview-section"><h1 class="page-title heading inline-title" id="平衡多路查找树（B树）"><p>平衡多路查找树（B树）</p></h1><div class="heading-wrapper"><h2 data-heading="从二分法到二叉树" class="heading" id="从二分法到二叉树"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>从二分法到二叉树</h2><div class="heading-children"><div><p>首先介绍二分法，二分法是我们常用的一种查找算法，具体实现思路如下</p></div><div><ol>
<li data-line="0" class="lc-list-callout" style="--lc-callout-color: 124, 77, 255;"><span class="lc-li-wrapper"><span class="lc-list-marker"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-activity-square"><rect x="3" y="3" width="18" height="18" rx="2"></rect><path d="M17 12h-2l-2 5-2-10-2 5H7"></path></svg></span> 首先对数据集进行排序。</span></li>
<li data-line="1" class="lc-list-callout" style="--lc-callout-color: 124, 77, 255;"><span class="lc-li-wrapper"><span class="lc-list-marker"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-activity-square"><rect x="3" y="3" width="18" height="18" rx="2"></rect><path d="M17 12h-2l-2 5-2-10-2 5H7"></path></svg></span> 找到数据集中间位置的节点。</span></li>
<li data-line="2" class="lc-list-callout" style="--lc-callout-color: 124, 77, 255;"><span class="lc-li-wrapper"><span class="lc-list-marker"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-activity-square"><rect x="3" y="3" width="18" height="18" rx="2"></rect><path d="M17 12h-2l-2 5-2-10-2 5H7"></path></svg></span> 用查找的条件和中间节点进行比较，等于则直接返回，中间节点数据小于查找条件则说明数据在排序列表的左边，大于则说明数据在排序列表的右边。</span></li>
</ol></div><div><p>也就是说，如果我们能保证数据的有序性，并且预先把数据分段，然后把数据的中间节点储存好，那么查找的时候就会更简单，所以我们演化出了跳表  <a data-href="Redis 跳表" href="2-领域/后端学习/redis/知识点/redis-跳表.html" class="internal-link" target="_self" rel="noopener">Redis 跳表</a> 和<strong>树</strong>的结构</p></div><div><p>下面就是树的结构<img alt="image.png" src="https://obsidian-pic-1317906728.cos.ap-nanjing.myqcloud.com/obsidian/20240220233103.png" referrerpolicy="no-referrer"></p></div><div><div data-callout-metadata="" data-callout-fold="" data-callout="note" class="callout"><div class="callout-title"><div class="callout-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-pencil"><path d="M17 3a2.85 2.83 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5Z"></path><path d="m15 5 4 4"></path></svg></div><div class="callout-title-inner">那么这个就是二叉树</div></div></div></div></div></div><div class="heading-wrapper"><h2 data-heading="从二叉树到平衡二叉树" class="heading" id="从二叉树到平衡二叉树"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>从二叉树到平衡二叉树</h2><div class="heading-children"><div><div data-callout-metadata="" data-callout-fold="-" data-callout="faq" class="callout is-collapsible is-collapsed"><div class="callout-title"><div class="callout-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-help-circle"><circle cx="12" cy="12" r="10"></circle><path d="M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3"></path><path d="M12 17h.01"></path></svg></div><div class="callout-title-inner">我们构建二叉树需要怎样的操作呢</div><div class="callout-fold is-collapsed"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-chevron-down"><path d="m6 9 6 6 6-6"></path></svg></div></div><div class="callout-content" style="display: none;">
<p>平衡算法<br>
相同的数据插入的先后顺序不一样就可能变成线性结构，如下 <img alt="image.png" src="https://obsidian-pic-1317906728.cos.ap-nanjing.myqcloud.com/obsidian/20240220233502.png" referrerpolicy="no-referrer"> 所以我们必须要有一种方式来保证二叉树节点的平衡，让树的节点高度差不会太大，这个时候就衍生了一些平衡算法，最终我们的二叉树就有像 AVL 树和红黑树这些新产品，我们也称这些新产品为<strong>平衡二叉树</strong>，，平衡二叉树通常会保证树的左右两边的节点层级相差不会大于2。</p>
</div></div></div><div><p><img alt="image.png" src="https://obsidian-pic-1317906728.cos.ap-nanjing.myqcloud.com/obsidian/20240220234020.png" referrerpolicy="no-referrer"></p></div><div><p><img alt="image.png" src="https://obsidian-pic-1317906728.cos.ap-nanjing.myqcloud.com/obsidian/20240220234031.png" referrerpolicy="no-referrer"></p></div><div class="heading-wrapper"><h3 data-heading="平衡二叉树" class="heading" id="平衡二叉树"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>平衡二叉树</h3><div class="heading-children"><div><p>当二叉树节点分布不均匀的时候，会极大影响数据查询的性能，为了保证数据的均衡性，就有了平衡二叉树的结构，平衡算法暂不赘述，有时间看看</p></div><div><ul class="contains-task-list">
<li data-line="0" data-task="" class="task-list-item"><input data-line="0" type="checkbox" class="task-list-item-checkbox"> 平衡算法可以研究一下<br>
这里讲一下<strong>构建规则</strong></li>
</ul></div><div class="heading-wrapper"><h4 data-heading="平衡二叉树的构建规则" class="heading" id="平衡二叉树的构建规则"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>平衡二叉树的构建规则</h4><div class="heading-children"><div><p>三大特点</p></div><div><ol>
<li data-line="0" class="lc-list-callout" style="--lc-callout-color: 124, 77, 255;"><span class="lc-li-wrapper"><span class="lc-list-marker"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-activity-square"><rect x="3" y="3" width="18" height="18" rx="2"></rect><path d="M17 12h-2l-2 5-2-10-2 5H7"></path></svg></span> 非叶子节点只能允许最多两个子节点存在</span></li>
<li data-line="1" class="lc-list-callout" style="--lc-callout-color: 124, 77, 255;"><span class="lc-li-wrapper"><span class="lc-list-marker"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-activity-square"><rect x="3" y="3" width="18" height="18" rx="2"></rect><path d="M17 12h-2l-2 5-2-10-2 5H7"></path></svg></span> 每一个节点左边子节点值小于当前节点，右边值大（算法算出来的值）</span></li>
<li data-line="2" class="lc-list-callout" style="--lc-callout-color: 124, 77, 255;"><span class="lc-li-wrapper"><span class="lc-list-marker"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-activity-square"><rect x="3" y="3" width="18" height="18" rx="2"></rect><path d="M17 12h-2l-2 5-2-10-2 5H7"></path></svg></span> 通过平衡算法（比如 Treap、AVL、红黑树）保证左右节点的高度相差不超过 2 层</span></li>
</ol></div></div></div></div></div><div class="heading-wrapper"><h3 data-heading="B 树" class="heading" id="B_树"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>B 树</h3><div class="heading-children"><div><ul class="contains-task-list">
<li data-line="0" data-task="x" class="task-list-item is-checked"><input data-line="0" checked="" type="checkbox" class="task-list-item-checkbox">没写完到时候看这个 <a data-tooltip-position="top" aria-label="https://zhuanlan.zhihu.com/p/27700617" rel="noopener" class="external-link" href="https://zhuanlan.zhihu.com/p/27700617" target="_blank">平衡二叉树、B树、B+树、B*树 理解其中一种你就都明白了 - 知乎</a> 📅 2024-02-22 ✅ 2024-02-22<br>
B 树和平衡二叉树的不同之处是：B 树属于多叉树又名平衡多路查找树（查找路径不止两个），数据库索引技术里大量使用着 B 树和 B+树的数据结构。</li>
<li data-line="2" class="lc-list-callout" style="--lc-callout-color: 255, 214, 0;"><span class="lc-li-wrapper"><span class="lc-list-marker"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-alert-octagon"><polygon points="7.86 2 16.14 2 22 7.86 22 16.14 16.14 22 7.86 22 2 16.14 2 7.86 7.86 2"></polygon><line x1="12" y1="8" x2="12" y2="12"></line><line x1="12" y1="16" x2="12.01" y2="16"></line></svg></span> 注意 B 树和 B-tree 是同一种树</span></li>
</ul></div><div class="heading-wrapper"><h4 data-heading="B 树的构建规则" class="heading" id="B_树的构建规则"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>B 树的构建规则</h4><div class="heading-children"><div><p>有四大特点，说实话没太明白</p></div><div><ol>
<li data-line="0">排序方式：所有关键字是按<strong>递增次序</strong>排列，左小右大</li>
<li data-line="1">子节点数：非叶节点（根节点和枝节点）的子节点数 &gt;1、且子节点数&lt;=M、且M&gt;=2，空树除外（注：M 阶代表一个树节点最多有多少个查找路径，M=M 路,当 M=2则是2叉树,M=3则是3叉）</li>
<li data-line="2"><strong>关键字数</strong>：枝节点的关键字数量大于等于 ceil(m/2)-1个且小于等于 M-1（注：ceil()是个朝正无穷方向取整的函数如 ceil(1.1)结果为 2);关键字就是指的是一个节点里面的'值'的数量，<mark>比如下面的图，M 是一个关键字，他有两个子树，DG 是两个关键字，下面有三个子树</mark>，每一层加 1</li>
<li data-line="3">所有叶子节点均在同一层、叶子节点除了包含了关键字 和 关键字记录的指针外，也有指向其子节点的指针只不过其指针地址都为null对应下图最后一层节点的空格子;</li>
</ol></div><div><p>上面比较难理解，下图可以看 B 树，通过他的插入和查询可以很好的理解 b 树 <img alt="image.png" src="https://obsidian-pic-1317906728.cos.ap-nanjing.myqcloud.com/obsidian/20240222222707.png" referrerpolicy="no-referrer"></p></div></div></div><div class="heading-wrapper"><h4 data-heading="B 树的查找流程" class="heading" id="B_树的查找流程"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>B 树的查找流程</h4><div class="heading-children"><div><p>他的查找过程如下<br>
如上图我要从上图中找到E字母，查找流程如下</p></div><div><ol>
<li data-line="0">获取根节点的关键字进行比较，当前根节点关键字为 M，E&lt;M（26个字母顺序），所以往找到指向左边的子节点（二分法规则，左小右大，左边放小于当前节点值的子节点、右边放大于当前节点值的子节点）；</li>
<li data-line="1">拿到关键字 D 和 G，D&lt;E&lt;G 所以直接找到 D 和 G 中间的节点；</li>
<li data-line="2">拿到 E 和 F，因为 E=E 所以直接返回关键字和指针信息（如果树结构里面没有包含所要查找的节点则返回 null）；</li>
</ol></div></div></div><div class="heading-wrapper"><h4 data-heading="B 树的插入流程" class="heading" id="B_树的插入流程"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>B 树的插入流程</h4><div class="heading-children"><div><ol>
<li data-line="0" class="lc-list-callout" style="--lc-callout-color: 124, 77, 255;"><div class="list-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="lc-li-wrapper"><span class="lc-list-marker"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-activity-square"><rect x="3" y="3" width="18" height="18" rx="2"></rect><path d="M17 12h-2l-2 5-2-10-2 5H7"></path></svg></span> 定义一个5阶树（平衡5路查找树;），现在我们要把3、8、31、11、23、29、50、28、53 这些数字构建出一个5阶树出来
</span><ol>
<li data-line="1">节点拆分规则：当前是要组成一个5路查找树，那么此时m=5,关键字数必须&lt;=5-1（这里关键字数&gt;4就要进行节点拆分）</li>
<li data-line="2">排序规则：满足节点本身比左边节点大，比右边节点小的排序规则</li>
<li data-line="3" class="lc-list-callout" style="--lc-callout-color: 158, 158, 158;"><span class="lc-li-wrapper"><span class="lc-list-marker"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-air-vent"><path d="M6 12H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2v5a2 2 0 0 1-2 2h-2"></path><path d="M6 8h12"></path><path d="M18.3 17.7a2.5 2.5 0 0 1-3.16 3.83 2.53 2.53 0 0 1-1.14-2V12"></path><path d="M6.6 15.6A2 2 0 1 0 10 17v-5"></path></svg></span> 首先插入 3、8、31、11<img alt="image.png" src="https://obsidian-pic-1317906728.cos.ap-nanjing.myqcloud.com/obsidian/20240222223559.png" referrerpolicy="no-referrer"></span></li>
<li data-line="4" class="lc-list-callout" style="--lc-callout-color: 158, 158, 158;"><span class="lc-li-wrapper"><span class="lc-list-marker"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-air-vent"><path d="M6 12H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2v5a2 2 0 0 1-2 2h-2"></path><path d="M6 8h12"></path><path d="M18.3 17.7a2.5 2.5 0 0 1-3.16 3.83 2.53 2.53 0 0 1-1.14-2V12"></path><path d="M6.6 15.6A2 2 0 1 0 10 17v-5"></path></svg></span> 然后插入23、29<img alt="image.png" src="https://obsidian-pic-1317906728.cos.ap-nanjing.myqcloud.com/obsidian/20240222223641.png" referrerpolicy="no-referrer"></span></li>
<li data-line="5" class="lc-list-callout" style="--lc-callout-color: 158, 158, 158;"><span class="lc-li-wrapper"><span class="lc-list-marker"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-air-vent"><path d="M6 12H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2v5a2 2 0 0 1-2 2h-2"></path><path d="M6 8h12"></path><path d="M18.3 17.7a2.5 2.5 0 0 1-3.16 3.83 2.53 2.53 0 0 1-1.14-2V12"></path><path d="M6.6 15.6A2 2 0 1 0 10 17v-5"></path></svg></span> 最后插入 50 28 53<img alt="image.png" src="https://obsidian-pic-1317906728.cos.ap-nanjing.myqcloud.com/obsidian/20240222223707.png" referrerpolicy="no-referrer"></span></li>
</ol>
</li>
</ol></div></div></div><div class="heading-wrapper"><h4 data-heading="B 树节点的删除" class="heading" id="B_树节点的删除"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>B 树节点的删除</h4><div class="heading-children"><div><p><img alt="image.png" src="https://obsidian-pic-1317906728.cos.ap-nanjing.myqcloud.com/obsidian/20240222224333.png" referrerpolicy="no-referrer"></p></div><div><ol>
<li data-line="0">节点合并规则：当前是要组成一个5路查找树，那么此时 m=5,关键字数必须大于等于 ceil(m/2)-1（所以这里关键字数&lt;2就要进行节点合并）。</li>
<li data-line="1">满足节点本身比左边节点大，比右边节点小的排序规则。</li>
<li data-line="2">关键字数小于二时先从子节点取，子节点没有符合条件时就向父节点取，取中间值往父节点放。</li>
</ol></div></div></div></div></div><div class="heading-wrapper"><h3 data-heading="额外注释" class="heading" id="额外注释"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>额外注释</h3><div class="heading-children"><div><p><img alt="image.png" src="https://obsidian-pic-1317906728.cos.ap-nanjing.myqcloud.com/obsidian/20240222225201.png" referrerpolicy="no-referrer"><br>
上图数字 1、3、7是叶子节点；（因为他们下面没有分叉出子节点，所以称为：叶子节点）【度为0】<br>
数字2、8是子节点； （除了根节点、叶子节点之外的，都称为：子节点）【度为1】<br>
数字5是根节点；（因为他是最顶部，所以称为：根节点）【度为2】</p></div><div><p><strong>关键字</strong> 就理解为数据就行了</p></div></div></div><div class="heading-wrapper"><h3 data-heading="总结" class="heading" id="总结"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>总结</h3><div class="heading-children"><div><p>平衡二叉树和 b 树都是一种数据结构，他们的特点是平衡，这种结构能让人更快的查询到需要的数据，两者的查询使我们能够在最坏情况下也保持 O(LogN)的时间复杂度实现查找，两者也有<strong>区别</strong></p></div><div><p><mark>平衡二叉树：</mark></p></div><div><ol>
<li data-line="0"><div class="list-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>平衡二叉树从二叉树过来，因为二叉树的规则，<strong>左小右大</strong>不足以控制二叉树的高度，可能会出现二叉树变成一条线性结构的情况出现，所以加上了<strong>平衡算法</strong>以及一些规则补齐了这些，规则包括
<ol>
<li data-line="1" class="lc-list-callout" style="--lc-callout-color: 124, 77, 255;"><span class="lc-li-wrapper"><span class="lc-list-marker"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-activity-square"><rect x="3" y="3" width="18" height="18" rx="2"></rect><path d="M17 12h-2l-2 5-2-10-2 5H7"></path></svg></span> 非叶子节点只能允许最多两个子节点存在，就是说，分叉最多分俩，但是最下面的叶子节点除外</span></li>
<li data-line="2" class="lc-list-callout" style="--lc-callout-color: 124, 77, 255;"><span class="lc-li-wrapper"><span class="lc-list-marker"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-activity-square"><rect x="3" y="3" width="18" height="18" rx="2"></rect><path d="M17 12h-2l-2 5-2-10-2 5H7"></path></svg></span> 左小右大，值是根据 hash 算法算出来的</span></li>
<li data-line="3" class="lc-list-callout" style="--lc-callout-color: 255, 214, 0;"><span class="lc-li-wrapper"><span class="lc-list-marker"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-alert-octagon"><polygon points="7.86 2 16.14 2 22 7.86 22 16.14 16.14 22 7.86 22 2 16.14 2 7.86 7.86 2"></polygon><line x1="12" y1="8" x2="12" y2="12"></line><line x1="12" y1="16" x2="12.01" y2="16"></line></svg></span> 平衡算法，这个不太清楚，但是这个保证了树左右的高度差不超过 2 层，不会左边一大堆，右边只有一层</span></li>
</ol>
</li>
</ol></div><div><p><mark>B 树：</mark><br>
B 树看上去跟平衡二叉树没什么大区别，但是他有几个比较大的不同</p></div><div><ol>
<li data-line="0"><div class="list-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>他不限制子节点数一定为 2，
<ol>
<li data-line="1" class="lc-list-callout" style="--lc-callout-color: 124, 77, 255;"><span class="lc-li-wrapper"><span class="lc-list-marker"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-activity-square"><rect x="3" y="3" width="18" height="18" rx="2"></rect><path d="M17 12h-2l-2 5-2-10-2 5H7"></path></svg></span> 子节点数：非叶节点（根节点和枝节点）的子节点数 &gt;1、且子节点数量&lt;=M 、且M&gt;=2，空树除外（注：M阶代表一个树节点最多有多少个查找路径，M=M路,当M=2则是2叉树,M=3则是3叉）；</span></li>
</ol>
</li>
<li data-line="2">他的所有叶子节点均在一层</li>
<li data-line="3">关键字的设定，关键字就是一个节点里面存的那个值，一个结点中包含多个关键字（如n个关键字），那么它就对应有n+1个孩子结点</li>
<li data-line="4" class="lc-list-callout" style="--lc-callout-color: 0, 184, 212;"><span class="lc-li-wrapper"><span class="lc-list-marker"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-atom"><circle cx="12" cy="12" r="1"></circle><path d="M20.2 20.2c2.04-2.03.02-7.36-4.5-11.9-4.54-4.52-9.87-6.54-11.9-4.5-2.04 2.03-.02 7.36 4.5 11.9 4.54 4.52 9.87 6.54 11.9 4.5Z"></path><path d="M15.7 15.7c4.52-4.54 6.54-9.87 4.5-11.9-2.03-2.04-7.36-.02-11.9 4.5-4.52 4.54-6.54 9.87-4.5 11.9 2.03 2.04 7.36.02 11.9-4.5Z"></path></svg></span> 他的优势在于相对平衡二叉树在节点空间的利用率上进行改进，B 树在每个节点保存更多的数据，减少了树的高度，从而提升了查找的性能</span></li>
</ol></div></div></div></div></div><div class="heading-wrapper"><h2 data-heading="B+树" class="heading" id="B+树"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>B+树</h2><div class="heading-children"><div><p>B+ 树是在 B 树的基础上又一次的改进，提升了两个方面</p></div><div><ol>
<li data-line="0">查询的稳定性</li>
<li data-line="1">数据排序方面更加友好</li>
</ol></div><div class="heading-wrapper"><h3 data-heading="B +树的构建规则" class="heading" id="B_+树的构建规则"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>B +树的构建规则</h3><div class="heading-children"><div><ol>
<li data-line="0">B+ 树的<strong>非叶子节点不保存具体的数据，只保存关键字的索引</strong>，所有的数据都保存到叶子节点，所以每次查询的次数都会是一样的，查询速度就比较稳定，而 B 树在查找的过程中，不同关键字查找的速度都不同，有的可能在根节点，有的可能在叶子节点</li>
<li data-line="1">B+树的叶子节点有序排列，左边结尾数据会保存右边节点开始数据的指针</li>
<li data-line="2">其非叶子节点的子节点数=关键字数</li>
</ol></div><div><p><img alt="image.png" src="https://obsidian-pic-1317906728.cos.ap-nanjing.myqcloud.com/obsidian/20240303165808.png" referrerpolicy="no-referrer"></p></div></div></div></div></div><div class="heading-wrapper"><h2 data-heading="B 树和 B+树的对比" class="heading" id="B_树和_B+树的对比"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>B 树和 B+树的对比</h2><div class="heading-children"><div><ol>
<li data-line="0">B+树查询速度更稳定</li>
<li data-line="1">B+树天然具备排序功能，B+树所有叶子节点数据构成了一个有序链表，查询大小区间数据的时候更加方便</li>
<li data-line="2">B+树遍历速度更快，它只需要遍历所有的叶子节点就行，不需要对每一层进行遍历</li>
</ol></div><div class="mod-footer"></div></div></div></div></div></div><div class="sidebar-right sidebar"><div class="sidebar-handle"></div><div class="sidebar-topbar"><div class="topbar-content"></div><div class="clickable-icon sidebar-collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="100%" height="100%" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" class="svg-icon"><path d="M21 3H3C1.89543 3 1 3.89543 1 5V19C1 20.1046 1.89543 21 3 21H21C22.1046 21 23 20.1046 23 19V5C23 3.89543 22.1046 3 21 3Z"></path><path d="M10 4V20"></path><path d="M4 7H7"></path><path d="M4 10H7"></path><path d="M4 13H7"></path></svg></div></div><div class="sidebar-content"><div class="graph-view-wrapper"><div class="sidebar-section-header">Interactive Graph</div><div class="graph-view-placeholder">
		<div class="graph-view-container">
			<div class="graph-icon graph-expand" role="button" aria-label="Expand" data-tooltip-position="top"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon"><line x1="7" y1="17" x2="17" y2="7"></line><polyline points="7 7 17 7 17 17"></polyline></svg></div>
			<canvas id="graph-canvas" class="hide" width="512px" height="512px"></canvas>
		</div>
		</div></div><div class="tree-container mod-root nav-folder tree-item outline-tree" data-depth="0"><div class="tree-header"><span class="sidebar-section-header">Table Of Contents</span><button class="clickable-icon collapse-tree-button is-collapsed" aria-label="Collapse All"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></svg></button></div><div class="tree-scroll-area tree-item-children nav-folder-children"><div class="tree-item mod-tree-folder nav-folder mod-collapsible is-collapsed" style="display: none;"></div><div class="tree-item" data-depth="1"><a class="tree-link" href="2-领域\后端学习\java\平衡多路查找树（b树）.html#平衡多路查找树（B树）"><div class="tree-item-contents heading-link" heading-name="平衡多路查找树（B树）"><span class="tree-item-title">平衡多路查找树（B树）</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="2"><a class="tree-link" href="2-领域\后端学习\java\平衡多路查找树（b树）.html#从二分法到二叉树"><div class="tree-item-contents heading-link" heading-name="从二分法到二叉树"><span class="tree-item-title">从二分法到二叉树</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item mod-collapsible is-collapsed" data-depth="2"><a class="tree-link" href="2-领域\后端学习\java\平衡多路查找树（b树）.html#从二叉树到平衡二叉树"><div class="tree-item-contents heading-link" heading-name="从二叉树到平衡二叉树"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">从二叉树到平衡二叉树</span></div></a><div class="tree-item-children nav-folder-children" style="display: none;"><div class="tree-item mod-collapsible is-collapsed" data-depth="3"><a class="tree-link" href="2-领域\后端学习\java\平衡多路查找树（b树）.html#平衡二叉树"><div class="tree-item-contents heading-link" heading-name="平衡二叉树"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">平衡二叉树</span></div></a><div class="tree-item-children nav-folder-children" style="display: none;"><div class="tree-item" data-depth="4"><a class="tree-link" href="2-领域\后端学习\java\平衡多路查找树（b树）.html#平衡二叉树的构建规则"><div class="tree-item-contents heading-link" heading-name="平衡二叉树的构建规则"><span class="tree-item-title">平衡二叉树的构建规则</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item mod-collapsible is-collapsed" data-depth="3"><a class="tree-link" href="2-领域\后端学习\java\平衡多路查找树（b树）.html#B_树"><div class="tree-item-contents heading-link" heading-name="B 树"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">B 树</span></div></a><div class="tree-item-children nav-folder-children" style="display: none;"><div class="tree-item" data-depth="4"><a class="tree-link" href="2-领域\后端学习\java\平衡多路查找树（b树）.html#B_树的构建规则"><div class="tree-item-contents heading-link" heading-name="B 树的构建规则"><span class="tree-item-title">B 树的构建规则</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="2-领域\后端学习\java\平衡多路查找树（b树）.html#B_树的查找流程"><div class="tree-item-contents heading-link" heading-name="B 树的查找流程"><span class="tree-item-title">B 树的查找流程</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="2-领域\后端学习\java\平衡多路查找树（b树）.html#B_树的插入流程"><div class="tree-item-contents heading-link" heading-name="B 树的插入流程"><span class="tree-item-title">B 树的插入流程</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="2-领域\后端学习\java\平衡多路查找树（b树）.html#B_树节点的删除"><div class="tree-item-contents heading-link" heading-name="B 树节点的删除"><span class="tree-item-title">B 树节点的删除</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item" data-depth="3"><a class="tree-link" href="2-领域\后端学习\java\平衡多路查找树（b树）.html#额外注释"><div class="tree-item-contents heading-link" heading-name="额外注释"><span class="tree-item-title">额外注释</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="3"><a class="tree-link" href="2-领域\后端学习\java\平衡多路查找树（b树）.html#总结"><div class="tree-item-contents heading-link" heading-name="总结"><span class="tree-item-title">总结</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item mod-collapsible is-collapsed" data-depth="2"><a class="tree-link" href="2-领域\后端学习\java\平衡多路查找树（b树）.html#B+树"><div class="tree-item-contents heading-link" heading-name="B+树"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">B+树</span></div></a><div class="tree-item-children nav-folder-children" style="display: none;"><div class="tree-item" data-depth="3"><a class="tree-link" href="2-领域\后端学习\java\平衡多路查找树（b树）.html#B_+树的构建规则"><div class="tree-item-contents heading-link" heading-name="B +树的构建规则"><span class="tree-item-title">B +树的构建规则</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item" data-depth="2"><a class="tree-link" href="2-领域\后端学习\java\平衡多路查找树（b树）.html#B_树和_B+树的对比"><div class="tree-item-contents heading-link" heading-name="B 树和 B+树的对比"><span class="tree-item-title">B 树和 B+树的对比</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div></div></div></div><script defer="">let rs = document.querySelector(".sidebar-right"); rs.classList.add("is-collapsed"); if (window.innerWidth > 768) rs.classList.remove("is-collapsed"); rs.style.setProperty("--sidebar-width", localStorage.getItem("sidebar-right-width"));</script></div></div></body></html>